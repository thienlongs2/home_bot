#property copyright "Your Name"
#property link      "https://yourwebsite.com"
#property version   "1.01"

input double RiskPercent = 0.05; // Risk per trade (%)
input double TP = 120;           // Take Profit (pips)
input double SL = 70;            // Stop Loss (pips)
input int MagicNumber = 12345;   // Magic Number
input double MaxPriceDeviation = 10; // Độ lệch tối đa so với giá API (pips)
input string API_KEY = "your_api_key_here"; // API Key

#include <Trade\Trade.mqh>
CTrade trade;

string url = "http://127.0.0.1:8000/get_signal";
string last_signal = "";

// Hàm khởi tạo EA
int OnInit() {
   trade.SetExpertMagicNumber(MagicNumber);
   Print("EA khởi tạo thành công với MagicNumber: ", MagicNumber);
   return(INIT_SUCCEEDED);
}

// Hàm xử lý mỗi tick
void OnTick() {
   string response = GetSignalFromServer();
   if (response != "" && response != "{}") {
      ProcessSignal(response);
   }
}

// Nhận tín hiệu từ server với API Key
string GetSignalFromServer() {
   if (!TerminalInfoInteger(TERMINAL_DLLS_ALLOWED)) {
      Print("Lỗi: Vui lòng cho phép WebRequest trong phần Cài đặt của MT5.");
      return "";
   }

   string request_url = url + "?api_key=" + API_KEY + "&mt5_account=" + IntegerToString(AccountInfoInteger(ACCOUNT_LOGIN));
   string headers;
   char result[];
   char post_data[];  // WebRequest cần một biến dữ liệu đầu vào, ngay cả khi không dùng

   ResetLastError();

   // Gọi WebRequest với đúng số lượng tham số
   int res = WebRequest("GET", request_url, "", 0, post_data, result, headers);

   if (res == 200) {
      string response = CharArrayToString(result);
      Print("Nhận tín hiệu thành công: ", response);
      return response;
   } else {
      Print("Lỗi nhận tín hiệu từ server. Mã lỗi: ", res, " | Lỗi hệ thống: ", GetLastError());
      return "";
   }
}


// Tính toán khối lượng lệnh dựa trên rủi ro
double CalculateLotSize(double stopLossPips) {
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = accountBalance * RiskPercent;
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);

   if (tickValue == 0 || tickSize == 0) {
      Print("Lỗi: Tick Value hoặc Tick Size không hợp lệ");
      return 0.01;
   }

   double lotSize = riskAmount / (stopLossPips * tickValue / tickSize);

   lotSize = NormalizeDouble(lotSize, 2);

   return MathMax(lotSize, 0.01); // Đảm bảo khối lượng không nhỏ hơn 0.01
}

// Xử lý tín hiệu từ API
void ProcessSignal(string signal_json) {
   string signal = ExtractJsonValue(signal_json, "\"signal\":\"", "\"");
   int magic_number = (int)StringToInteger(ExtractJsonValue(signal_json, "\"magic_number\":", ","));
   double api_price = StringToDouble(ExtractJsonValue(signal_json, "\"current_price\":", ","));

   if (magic_number != MagicNumber) {
      Print("Magic Number không khớp: ", magic_number);
      return;
   }

   double current_bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double current_ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double price_deviation = MathAbs(current_bid - api_price) * 10000;

   if (price_deviation > MaxPriceDeviation) {
      Print("Giá lệch quá ", MaxPriceDeviation, " pips, bỏ qua lệnh.");
      return;
   }

   if (CountOpenPositions() > 0 && signal == last_signal) {
      Print("Bỏ qua lệnh vì tín hiệu trùng lặp.");
      return;
   }

   if (signal == "buy") {
      OpenBuy(current_ask);
   } else if (signal == "sell") {
      OpenSell(current_bid);
   } else if (signal == "close") {
      CloseAll();
   }
   last_signal = signal;
}

// Mở lệnh Buy
void OpenBuy(double ask) {
   double lotSize = CalculateLotSize(SL);
   double sl = ask - SL * _Point * 10;
   double tp = ask + TP * _Point * 10;
   if (!trade.Buy(lotSize, _Symbol, ask, sl, tp)) {
      Print("Lỗi mở lệnh Buy: ", GetLastError());
   } else {
      Print("Đã mở lệnh Buy tại: ", ask, " với lot size: ", lotSize);
   }
}

// Mở lệnh Sell
void OpenSell(double bid) {
   double lotSize = CalculateLotSize(SL);
   double sl = bid + SL * _Point * 10;
   double tp = bid - TP * _Point * 10;
   if (!trade.Sell(lotSize, _Symbol, bid, sl, tp)) {
      Print("Lỗi mở lệnh Sell: ", GetLastError());
   } else {
      Print("Đã mở lệnh Sell tại: ", bid, " với lot size: ", lotSize);
   }
}

// Đóng tất cả lệnh
void CloseAll() {
   for (int i = PositionsTotal() - 1; i >= 0; i--) {
      if (PositionSelectByTicket(PositionGetTicket(i))) {
         if (PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
            trade.PositionClose(PositionGetTicket(i));
            Print("Đã đóng lệnh: ", PositionGetTicket(i));
         }
      }
   }
}

// Đếm số lệnh đang mở với MagicNumber
int CountOpenPositions() {
   int count = 0;
   for (int i = PositionsTotal() - 1; i >= 0; i--) {
      if (PositionSelectByTicket(PositionGetTicket(i))) {
         if (PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
            count++;
         }
      }
   }
   return count;
}

// Trích xuất giá trị từ JSON
string ExtractJsonValue(string json, string key, string end_char) {
   int start_pos = StringFind(json, key) + StringLen(key);
   int end_pos = StringFind(json, end_char, start_pos);
   if (start_pos >= 0 && end_pos > start_pos) {
      return StringSubstr(json, start_pos, end_pos - start_pos);
   }
   return "";
}

// Hàm dọn dẹp
void OnDeinit(const int reason) {
   Print("EA đã dừng, lý do: ", reason);
}
